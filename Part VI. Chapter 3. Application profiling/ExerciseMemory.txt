
1. Запущенная утилита мониторинга всегда должна находиться в так называемом "состоянии покоя".
Т.е. если наше приложение ничего не делает - на индикаторах не должно быть каких-то непонятных "скачков".
В противном случае показания могут не соответствовать действительности.
2. С другой стороны, если у нас возникает проблема, то чем больше показаний у нас будет - тем легче найти проблему.
3. Т.к. мы замеряем практически неработающее приложение, будем исходить из первого предположения.
4. Хорошо бы использовать какое-то нагрузочное тестирование, т.к. тест маленького приложения на индикаторах будет отражаться не очень существенно.
Именно поэтому создадим новый тест StartUIPerfomanceTest:
- создание 100 000 заявок
- удаление 100 000 заявок 
- повторное создание 100 000 заявок
- повторное удаление 100 000 заявок 
запустим его, подключимся к его процессу и будем следить за состоянием индикаторов.

I. jconsole
Изначально по какой-то причине индикатор "Heap memory usage"  скачет в пределах 3-17 Мб. 
Это либо издержки производительности профайлера, либо особенность работы Heap.
1. создание заявок
- закладка "Overview" - на индикаторах хорошо видно работу приложения:
	- heap - скачет в пределах 20-130 Мб
	- threads - отображен линейно на значении 13
	- classes - незначительно растет
	- CPU Usage - скачет в пределах 10-30%
- закладка "Classes" - увеличилось значение классов
- закладка "Memory" - увеличилось значение использованной памяти
2. удаление заявок
- закладка "Overview":
	- heap - скачет также, как и в момент создания
	- threads - упал до 12
	- classes - перестал расти
	- CPU Usage - упал практически до 0%
- закладка "Classes" - значение классов осталось на предыдущем уровне
- закладка "Memory" - уменьшилось значение использованной памяти
3. повторное создание/удаление заявок показывает идентичные результаты
4. остановка приложения - индикаторы сбросились до своих значений на момент запуска нагрузочного теста

- закладка "Threads" - нам сейчас не особенно интересна, т.к. приложение не многопоточное
- закладка "VM Summary" - информации много и она вся понятна, но смысловой нагрузки пока в ней не наблюдаю
- на закладке "MBeans" (com.sun.management->HotSpotDiagnostic->Operations->dumpHeap) существует возможность сделать дамп 
текущего состояния Heap для последующего анализа (вместо String первого поля нужно написать имя файла дампа).
Фактически это дамп текущей проблемы для последующего анализа сторонними приложениями (коммерческие, либо VisualVM). 
Хорошо использовать, когда мы видим наличие проблемы, которая может исчезнуть также, как и появилась и т.д.

Итого: Данное приложение хорошо использовать для разработки, но не рекомендуется для продуктивных сред, 
т.к. jconsole использует существенные системные ресурсы.

II. visual vm
1. создание заявок
- закладка Visual GC:
	- наглядно видна работа heap: Eden, OldGen и т.д. 
- закладка Monitor:
	- CPU скачет в пределах 5-15%
	- Classes - индикатор незначительно вырос до определенного значения
	- Threads - здесь поток частично линеен, в момент удаления заявок он сбрасывается до 10, а в момент создания поднимается до 13
	- Heap, PermGen - их работа видна прям в online
- закладка Profiler
	- отобразились индикаторы, которые, я полагаю, показывают занимаемую объектами память и ее процентное соотношение
	данные показатели хорошо помогут в отслеживании "узких мест" приложения, проблем и т.д
	
Итого: в целом данная утилита показала больше графиков и информации, которые могли бы помочь в отслеживании проблем с приложением.

III. jmap
1. изначальный запуск утилиты:
- видно, что используется сборщик мусора - Parallel GC с двумя потоками
- также видны все показатели heap: новое и старое поколение, PermGen и т.д.
2. запуск утилиты во время работы нагрузочного теста:
- видно, что показатели heap изменились

Итого: утилита делает дамп текущего состояния heap. Может помочь в выяснении причин разрастания heap, который не сокращается и т.д.

IV. jstack
Данная утилита снимает dump потоков, запущенных в приложении, что и видно в консоли.

Итого: может помочь, если необходимо отследить почему приложение внезапно прекратило работу,
либо, если запустить с ключом -l, выяснить причины зависания или масштабируемости.
	
V. YourKit
Данная утилита показывает значительное количество графиков аналогично visual vm, включая IO, Sokets и мн.др.
Единственное, чего я в ней не нашел - индикаторов, показывающих сколько в памяти занимают объекты и их процентное соотношение (как в visual vm)
	
Итого: в целом, утилита довольно достойная. Если бы и использовал, то в совокупности с visual vm.
	
VI. jps
Показывает запущенные java-процессы


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Выход за пределы памяти и состояние vm.
Для того, чтобы вопроизвести данную ситуацию, необходимо создать в памяти большой объект, а лучше несколько больших объектов.
Создадим соответствующий тест StartUIOverHeapTest, в котором будем наполнять массив большими объектами.
Как инструмент для анализа heap будем использовать visual vm (закладка Visual GC).

- создаем объекты
- видим как заполняется OldGen
- при достижении порогового значения наш тест вылетел с ошибкой java.lang.OutOfMemoryError: Java heap space
- индикаторы на закладке Visual GC утилиты visual vm обнулены
- индикатор OldGen заполнен
- утилита прекратила свою работу с данным java-процессом

Ошибка, которую мы "поймали" говорит о том, что места в heap не осталось. Собственно это и есть одна из разновидностей утечек памяти.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
